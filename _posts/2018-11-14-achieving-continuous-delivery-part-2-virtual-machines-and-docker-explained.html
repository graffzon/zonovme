---
layout: post
title: Achieving Continuous Delivery. Part 2. Virtual machines and Docker explained
date: 2018-11-14 21:43:53.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Development
- DevOps
tags:
- containers
- continuous delivery
- continuous integration
- development
- devops
- docker
meta:
  _edit_last: '1'
  _adinserter_block_exceptions: ''
  hefo_before: '0'
  hefo_after: '0'
  _aioseop_description: Even if you heard the words "Docker" and "containers" and
    even have an understanding of their place in the world, this article will help
    you to build a more solid understanding of these concepts.
  _aioseop_title: Virtual machines, containers, and Docker explained
author:
  login: graffzon
  email: graffzon@gmail.com
  display_name: graffzon
  first_name: ''
  last_name: ''
permalink: "/achieving-continuous-delivery-part-2-virtual-machines-and-docker-explained/"
excerpt: "\n\t\t\t\t\t\t"
---
<p>
				How are you doing, fellow developers? Ready to dockerize your first application? Or what about finding out, what "dockerize" actually means? Let's start!</p>
<p>The structure of today's post will be the following:</p>
<ol>
<li>Understanding the Virtualization</li>
<li>How containers are different from Virtual Machines</li>
<li>Introduction to Docker concepts</li>
</ol>
<p><!--more--></p>
<h2>Virtualization</h2>
<p>[caption id="attachment_722" align="aligncenter" width="2560"]<img class="wp-image-722 size-full" src="{{ site.baseurl }}/assets/2018/11/photo5427257478980151812.jpg" alt="Virtualization" width="2560" height="1655" /> Photo by NeONBRAND on Unsplash[/caption]</p>
<p>The idea of containers is not new, it had been around since the late 90s. It is a successor of <em>virtualization</em> and <em>virtual machines (VMs).</em> If you have a MacOS (or Linux) as your home OS for long enough, most likely you ever tried to run some Windows-based applications on it. Especially it was important when Steam wasn't around or when you migrated from Windows and had a bunch of games and applications, which you got used to and wanted to run. In that situation, you had a choice. Either install Windows as a second operating system or use it in a Virtual Machine. If you have been in this situation, most likely you know some of the most famous VMs, like VirtualBox, Parallels Desktop, VMWare. You usually install them on your host OS. To show an inverted example, I can recall the times when I was getting familiar with Linux and was running a Mandriva distributive in a VirtualBox VM, running on Windows.</p>
<p>From the described setup we can now derive the understanding of what VMs are serving for. It helps you to run two or more different OSs <em>in isolation</em> to leverage the power of both. Importantly, as you might have noticed, in this setup you can run any combination of host OS and guest OSs. Furthermore, virtualization is not only useful for running your old Warcraft III Windows-based game on the MacOS, but it is also heavily used in the world of servers. The simplest example here can be some cloud provider. If you ever registered your <em>virtual private server (VPS)</em> on DigitalOcean, or an application on Heroku, or an EC2 machine (in some configuration) on AWS, remember, you were not choosing a real server from the server rack. Because I doubt that they would have a server with 512Mb RAM, but you still can choose it! You probably already started to understand that they are using the virtualization to create a server for you. Yet, the approach they take is a bit different than in the first example with games. They don't have a MacOS/Linux/Whatever OS, on top of which they create a virtual machine for you, it would be inefficient. Instead, they use a different level of virtualization. It is called the <em>hardware virtualization.</em></p>
<p>Now it's time to introduce one more important concept. It is the <em>Hypervisor</em>. I think that this word sounds very cool %)</p>
<p>[caption id="attachment_729" align="aligncenter" width="1920"]<img class="wp-image-729 size-full" src="{{ site.baseurl }}/assets/2018/11/photo5429509278793836878.jpg" alt="Two types of Hypervisors. Made by https://advtka.myportfolio.com/" width="1920" height="1080" /> Two types of Hypervisors[/caption]</p>
<p>Hypervisor is a software, that manages Virtual Machines. In case of the VirtualBox, Parallels Desktop and VMWare that tools will play the hypervisor role. Using them, you can create a requires type of VM, allocate needed resources, watch it, and remove it. The name of these and similar tools is <strong>Type-2 Hypervisors</strong>. Unlike the Type-2, the <strong>Type-1 Hypervisors</strong> run on bare metal and don't require any OS installed. Exactly they are used in the VPS/EC2 case described above. One of the well known Type-1 Hypervisors is Xen. Here is an illustration of both types:</p>
<p>[caption id="attachment_720" align="aligncenter" width="1140"]<img class="size-full wp-image-720" src="{{ site.baseurl }}/assets/2018/11/docker.png" alt="Hypervisor types illustration" width="1140" height="809" /> Hypervisor types illustration[/caption]</p>
<p>To be precise, I have to tell, that EC2 supports both virtualization types, Type-1 (hardware) and Type-2 (software or paravirtualization). You can find more information about their setup in the links at the end of the post.</p>
<h2>Containers</h2>
<p>The important feature of VM is that it contains everything required for its work inside itself. It allows you to run a Windows VM on your Ubuntu machine and vice versa. Thus it means that each VM includes the required kernel and packages, hence all these need some disk space and RAM. But at the same time, VMs help you to use the power of a machine on its max. Containers work in a different way. Let's have a look at the illustration:</p>
<p>[caption id="attachment_724" align="aligncenter" width="1220"]<img class="size-full wp-image-724" src="{{ site.baseurl }}/assets/2018/11/docker-2.png" alt="Virtual Machines and Containers illustrated" width="1220" height="811" /> VMs and Containers illustrated[/caption]</p>
<p><span data-offset-key="70pr8-0-0">Containers share the host OS's kernel and so they need less disk space to exist and less RAM to run. </span><span class="complexword"><span data-offset-key="70pr8-1-0">However</span></span><span data-offset-key="70pr8-2-0">, </span><span class="complexword"><span data-offset-key="70pr8-3-0">on the other hand</span></span><span data-offset-key="70pr8-4-0">, they cannot support completely different kernel types. </span><span class="veryhardreadability"><span data-offset-key="70pr8-5-0">Although I saw an option to run Linux containers on Windows Server, it still uses a virtualization, as the Hyper-V underneath. I didn't see the vice versa solution</span></span><span data-offset-key="70pr8-6-0">, however, it must be possible with the same approach.</span></p>
<p><span class="hardreadability"><span data-offset-key="5i8e0-0-0">Most likely you know the company and product Docker, which is a standard de-facto for the modern containers</span></span><span data-offset-key="5i8e0-1-0">. </span><span class="complexword"><span data-offset-key="5i8e0-2-0">However</span></span><span data-offset-key="5i8e0-3-0">, they weren't pioneers on containers space. The initial implementation had </span><span class="passivevoice"><span data-offset-key="5i8e0-4-0">been created</span></span><span data-offset-key="5i8e0-5-0"> in 1982 and </span><span class="passivevoice"><span data-offset-key="5i8e0-6-0">was called</span></span> <code>chroot</code><span data-offset-key="5i8e0-7-2">. </span><span class="hardreadability"><span data-offset-key="5i8e0-8-0">It is not as comprehensive containerization technology as we see them now, but the idea is very similar</span></span><span data-offset-key="5i8e0-9-0">. </span><span class="veryhardreadability"><span data-offset-key="5i8e0-10-0">This command allowed you to use different root folders for the different processes, thus providing a file-system "isolation"</span></span><span data-offset-key="5i8e0-11-0">. I put the word "isolation" in quotes because it wasn't a real isolation. E.g. </span><span class="veryhardreadability"><span data-offset-key="5i8e0-12-0">in Docker if you give your container access to a certain directory, it is impossible by the Docker design for this container to access other parts of your host file system</span></span><span data-offset-key="5i8e0-13-0">. </span><span class="complexword"><span data-offset-key="5i8e0-14-0">However</span></span><span class="hardreadability"><span data-offset-key="5i8e0-15-0">, in the case of the <code>chroot</code></span><span data-offset-key="5i8e0-15-2"> there was this possibility because it didn't have the </span><span data-offset-key="5i8e0-15-3">root</span><span data-offset-key="5i8e0-15-4"> user scope isolation</span></span><span data-offset-key="5i8e0-16-0">.</span></p>
<p><span class="hardreadability"><span data-offset-key="c8oa4-0-0">I mentioned about VMs that using them, you can leverage the whole power of the machine, because of a strict resources allocation</span></span><span data-offset-key="c8oa4-1-0">. For containers, it works </span><span class="adverb"><span data-offset-key="c8oa4-2-0">differently</span></span><span data-offset-key="c8oa4-3-0">. </span><span class="veryhardreadability"><span data-offset-key="c8oa4-4-0">Speaking about Docker, by default it doesn't limit your containers from </span></span><span class="adverb"><span data-offset-key="c8oa4-5-0">blindly</span></span><span class="veryhardreadability"><span data-offset-key="c8oa4-6-0"> consuming the whole pool of resources, including Ram, Filesystem, and CPU cycles</span></span><span data-offset-key="c8oa4-7-0">. </span><span class="complexword"><span data-offset-key="c8oa4-8-0">However</span></span><span class="hardreadability"><span data-offset-key="c8oa4-9-0">, there is a built-in mechanism, which allows you to set the hard constraints on the resources usage</span></span><span data-offset-key="c8oa4-10-0">.</span></p>
<p>I will emphasize this once again. It is also very important to understand that even tho your processes are isolated (contained) with Docker, they are still running on the same kernel.</p>
<h2>Docker</h2>
<div class="" data-block="true" data-editor="d76a7" data-offset-key="1rnh8-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="1rnh8-0-0"><span data-offset-key="1rnh8-0-0">As I already said, Docker is not the first and the only one on the containerization market. </span><span class="veryhardreadability"><span data-offset-key="1rnh8-1-0">It is the most common containerization solution nowadays, but, everything may change in a few years, as it always happens in our fast-paced world</span></span><span data-offset-key="1rnh8-2-0">. Even now I can point you to the number of </span><a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization#Implementations"><span data-offset-key="1rnh8-3-0">existing containerization solutions</span></a><span data-offset-key="1rnh8-4-0">. Anyway, learning Docker today makes the most sense. </span><span class="veryhardreadability"><span data-offset-key="1rnh8-5-0">You should already have an understanding of the purpose and approach, which Docker uses to deliver the containerization, and now let's define the basic concepts, what <strong>images</strong> and <strong>containers</strong> are</span></span><span data-offset-key="1rnh8-6-0">.</span></div>
</div>
<div class="" data-block="true" data-editor="d76a7" data-offset-key="d40fb-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="d40fb-0-0"><span data-offset-key="d40fb-0-0"> </span></div>
</div>
<div class="" data-block="true" data-editor="d76a7" data-offset-key="e06-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="e06-0-0"><span class="hardreadability"><span data-offset-key="e06-0-0"><strong>Image</strong> - is an executable package that includes everything needed to run an application</span></span><span data-offset-key="e06-1-0">. Like the code, libraries, environment variables, and configuration files.</span></div>
</div>
<div class="" data-block="true" data-editor="d76a7" data-offset-key="3h1rp-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="3h1rp-0-0"><span data-offset-key="3h1rp-0-0"> </span></div>
</div>
<div class="" data-block="true" data-editor="d76a7" data-offset-key="1hqk3-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="1hqk3-0-0"><span data-offset-key="1hqk3-0-0"><strong>Container</strong> - is a runtime instance of an <strong>image</strong>, which the <strong>image</strong> becomes when </span><span class="passivevoice"><span data-offset-key="1hqk3-1-0">is executed</span></span><span data-offset-key="1hqk3-2-0">. In other words, it is an image with the state. Containers can be running or stopped.</span></div>
</div>
<div class="" data-block="true" data-editor="d76a7" data-offset-key="fdr0a-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="fdr0a-0-0"><span data-offset-key="fdr0a-0-0"> </span></div>
</div>
<div class="" data-block="true" data-editor="d76a7" data-offset-key="48vcd-0-0">
<div class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr" data-offset-key="48vcd-0-0"><span data-offset-key="48vcd-0-0">It was easy, and now we're ready to have a closer look at the Docker internals. </span><span class="hardreadability"><span data-offset-key="48vcd-1-0">These should be valid now, based on public information, </span></span><span class="complexword"><span data-offset-key="48vcd-2-0">however</span></span><span class="hardreadability"><span data-offset-key="48vcd-3-0">, it is a product, which keeps evolving</span></span><span data-offset-key="48vcd-4-0">. Thus some parts might become obsolete or change in the future.</span></div>
</div>
<p>[caption id="attachment_727" align="aligncenter" width="383"]<img class=" wp-image-727" src="{{ site.baseurl }}/assets/2018/11/docker-3.png" alt="Docker architecture" width="383" height="448" /> Docker architecture[/caption]</p>
<p>The cornerstone of everything is the <strong>OS's Kernel</strong>. It is your Unix-system's kernel, as mentioned above, it is used by every container.</p>
<p><span data-offset-key="8tire-0-0">The second level, <strong>Docker Engine</strong>, is not </span><span class="qualifier"><span data-offset-key="8tire-1-0">just</span></span><span data-offset-key="8tire-2-0"> one tool. It is a big set of tools, which e.g. provide CLI to the end user, and RestAPI for the containers to talk to its daemon, </span><strong>dockerd</strong><span data-offset-key="8tire-2-2">. Moreover, it manages the network calls and isolated file systems for containers. Also, when you hear Docker Enterprise, it is actually the </span><span data-offset-key="8tire-2-3">Docker Engine</span><span data-offset-key="8tire-2-4"> Enterprise.</span></p>
<p>The next level is <strong>containerd</strong>. Containerd is a container manager. It manages containers' supervision, destruction, and creation, based on the images. Also, images management, like pull/push is also implemented on this level.</p>
<p>And the fourth level is <strong>runc</strong>. It is exactly the runtime tool, which runs containers, which are OCI (Open Container Initiative) compliant. Which basically means that runc potentially can be replaced by other tools, which follows the same standard.</p>
<p>Next concepts are sort of optional, however, you most likely will hear about them in the future.</p>
<p><span data-offset-key="1rnh8-0-0">Docker Compose is a tool, which helps you to orchestrate a set of containers. </span><span class="veryhardreadability"><span data-offset-key="1rnh8-1-0">Docker recomends the strategy that containers should be as atomic as possible, so perform one specific functionality</span></span><span data-offset-key="1rnh8-2-0">. E.g. </span><span class="veryhardreadability"><span data-offset-key="1rnh8-3-0">if you are running a microservices-based web application </span></span><span class="adverb"><span data-offset-key="1rnh8-4-0">locally</span></span><span class="veryhardreadability"><span data-offset-key="1rnh8-5-0">, you most likely would want to spin up at least 3-4 containers</span></span><span data-offset-key="1rnh8-6-0">. </span><span class="hardreadability"><span data-offset-key="1rnh8-7-0">Like microservice-1 (probably more than </span></span><span class="qualifier"><span data-offset-key="1rnh8-8-0">just</span></span><span class="hardreadability"><span data-offset-key="1rnh8-9-0"> one), database, message queue and </span></span><span class="adverb"><span data-offset-key="1rnh8-10-0">probably</span></span><span class="hardreadability"><span data-offset-key="1rnh8-11-0"> something else</span></span><span data-offset-key="1rnh8-12-0">. And docker-compose exists exactly to help you manage all them at once. </span> Literally with one command, like <code>docker-compose up</code> and that's it.</p>
<p>Docker Swarm is an even more optional tool, and it is actually also a part of the Docker Engine. This tool is dedicated to Docker clusters management. So, if you heard about AWS ECS or Kubernetes, they serve the same goal as Swarm, and moreover, more popular nowadays.</p>
<h2>Why Docker?</h2>
<p>Now, when we understand the Docker's place in the ecosystem, it is time to explain, why companies choose Docker and why should you.</p>
<p>The first reason is the development mode usage. When you're working in a microservices architecture, usually you cannot work with just one microservice up and running. In my experience, you also need a message queue, a database, most likely another microservice, and chances are high that it will also have a different database. Like in E-Commerce website you store your categories and products in a relational PostgreSQL for the Products microservice and in, e.g. MongoDB in Orders microservice. If don't use Docker, you must have these two databases on your machine, RabbitMQ installed and running and both microservices functioning at the same time as well. Can you imagine, how worse it may become if one of those is written in Ruby and another in Java? Brrr...</p>
<p>With Docker, and in this case Docker Compose, you will need just one command to spin up everything, that is required to your development setup. Sure, configuring it initially is not a trivial task, however, it is more than real and won't require years to build. In the future articles, we will develop a similar setup together.</p>
<p>The second reason is the production mode usage. Docker containers are stateless and contain everything required to run it. If in the old setup your deployment script had to ssh to your remote server, fetch the latest changes from git, perform the <code>bundle install</code>, and then restart a server, now you just replace one container with another. Images for these containers are built on your CI tool, which doesn't require any human interaction. This setup is about Ruby-based projects, but it works the same for languages like JavaScript or Python. I could assume that for compiled languages, e.g. Go, it is a less problematic process, however, Docker brings advantages for them as well.</p>
<p>The third, yet probably the most important is a production-development similarity. When you're using Docker, it is much easier to keep your development mode as close to production as possible. No need to use SQLite instead of PostgreSQL, and it is easy to spin up a microservice instead of mocking its behavior. Thus, you get a less error-prone development process, because many production-only errors will be catchable already in development.</p>
<p>It is not a comprehensive list, using Docker you can improve the security of your production system, make it easier to scale, and just provide you a clear definition of your project infrastructure dependencies in one place. It definitely worth your time, once you try it full power, you will never want to work with the old, "pre-docker"-era, setup anymore.</p>
<h2>The End</h2>
<p>Initially, I planned to include the hands-on part in this post, but it has grown already too big. Thus I dare to ask a little patience, we will start with the dockerization very soon and you will find out that it is much easier than you might think.</p>
<p>For today this is it; obviously, it is not the closest-possible look at Docker architecture, you can dive even deeper following the links below. However, the information provided here is more than enough to feel comfortable with the theoretical concepts.</p>
<p>Hope to see you next time! I will appreciate if you want to buy me a coffee, using a big orange button below or just share my post.</p>
<h2>References and further information:</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=wW9CAH9nSLs">https://www.youtube.com/watch?v=wW9CAH9nSLs</a> - first exposure of Docker to the world</li>
<li><a href="https://www.youtube.com/watch?v=kwsJIH5TGIg">https://www.youtube.com/watch?v=kwsJIH5TGIg</a> - Docker webinar. Great explanation, but an awful audio</li>
<li><a href="https://blog.docker.com/2017/09/preview-linux-containers-on-windows/">https://blog.docker.com/2017/09/preview-linux-containers-on-windows/</a> - Linux-based Docker containers on Windows</li>
<li><a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization#Implementations">https://en.wikipedia.org/wiki/Operating-system-level_virtualization#Implementations</a> different OS-level virtualizations</li>
<li><a href="https://docs.docker.com/config/containers/resource_constraints/">https://docs.docker.com/config/containers/resource_constraints/</a> - Constraining the containers' resources for Docker</li>
<li><a href="https://github.com/darshanime/notes/blob/master/kubernetes.org#notes">https://github.com/darshanime/notes/blob/master/kubernetes.org#notes</a> - Some synopsis from Kubernetes docs, where the containerization part is described</li>
<li><a href="https://caylent.com/containers-kubernetes-docker-swarm-amazon-ecs/">https://caylent.com/containers-kubernetes-docker-swarm-amazon-ecs/</a> - Docker Swarm, Kubernetes, and AWS ECS comparison</li>
<li><a href="https://blog.docker.com/2015/06/runc/">https://blog.docker.com/2015/06/runc/</a> - runc introduction by Docker</li>
<li><a href="https://blog.docker.com/2017/08/what-is-containerd-runtime/">https://blog.docker.com/2017/08/what-is-containerd-runtime/</a> - Containerd introduction by Docker</li>
<li><a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/virtualization_types.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/virtualization_types.html</a> - Virtualization types used at AWS EC2</li>
</ul>
<h1>Other chapters:</h1>
<ol>
<li><a href="http://zonov.me/achieving-continuous-delivery-part-1-what-are-the-ci-cd/" target="_blank" rel="noopener">Achieving Continuous Delivery. Part 1. What are the CI/CD?</a></li>
</ol>
