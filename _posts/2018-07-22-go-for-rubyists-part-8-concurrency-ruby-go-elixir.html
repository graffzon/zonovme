---
layout: post
title: Go for Rubyists. Part 8. Concurrency in Go, Ruby and Elixir
date: 2018-07-22 20:31:20.000000000 +02:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Development
tags:
- development
- elixir
- golang
- ruby
- tutorial
meta:
  _edit_last: '1'
  _adinserter_block_exceptions: ''
  hefo_before: '0'
  hefo_after: '0'
  _syntaxhighlighter_encoded: '1'
  _oembed_58d60c718b5286ddf08b12cccf12e816: "{{unknown}}"
  _aioseop_description: 'Comparison of concurrency implementation and in Go, Ruby,
    and Elixir. '
  _aioseop_title: Go for Rubyists. Concurrency in Go, Ruby and Elixir
author:
  login: graffzon
  email: graffzon@gmail.com
  display_name: graffzon
  first_name: ''
  last_name: ''
permalink: "/go-for-rubyists-part-8-concurrency-ruby-go-elixir/"
excerpt: "\n\t\t\t\t\t\t"
---
<p>
				Hey folks, hope you had a great weekend and it's time to learn something new!<br />
Today we will observe the concurrency topic, and since it's not such a fair comparison for Ruby, who's forte is definitely not a concurrency, I will add Elixir to today's article. However, still, since the series is about Go, the main focus will be on it. Don't expect performance comparison, I believe it's not fair to compare these languages since they all have slightly different focuses.</p>
<p><!--more--></p>
<p>[caption id="attachment_667" align="aligncenter" width="640"]<img class="size-large wp-image-667" src="{{ site.baseurl }}/assets/2018/07/studio-314-270213-unsplash-1024x752.jpg" alt="River with tributaries" width="640" height="470" /> River with tributaries. Photo by Studio 314 on Unsplash[/caption]</p>
<p>Let's first set some baselines. Few terms we operate, when speaking about concurrency are:</p>
<ul>
<li>Thread</li>
<li>Process</li>
<li>Concurrency</li>
</ul>
<h2>Thread</h2>
<p>Thread is a sequence of computer instructions, which can be executed independently and usually managed by the OS. It is important to understand that multiple threads can belong to the same process and share its memory. They're executed not exactly in parallel, but sequentially with interruptions.</p>
<h2>Process</h2>
<p>Process is a bigger <em>thing</em>. It has its own memory address space, can be executed in a real parallel way by leveraging multiprocessor architecture and the communication between them is usually possible only by using the OS-defined mechanisms.</p>
<h2>Concurrency</h2>
<p>In general, concurrency means the ability of functions to be executed "in parallel". The traditional way of achieving concurrency is by using multiple threads.</p>
<h1>Ruby MRI</h1>
<p>If you're working with Ruby, you most likely know that not such a long time ago Ruby didn't have "real" threads at all. The only threads we had were "green threads". Which are still executed in the same thread, so they are not really threads, but it's too early to blame Ruby! We now have native threads, but using GIL, which stands for Global Interpreter Lock. It is a perfect solution, when you want to use only one processor core. Because even if you have more, GIL is still one and it doesn't really leverage the multi-processor advantages.<br />
Also, speaking about the future of Ruby, the community and Matz himself started moving towards having less safe, but more viable concurrency models and apparently we will see the Actor model in Ruby.</p>
<h2>Ruby inter-thread communication</h2>
<p>Sometimes you want your threads to exchange some data, e.g. if your thread intended to run some other threads, which can then be waiting for some data be computed somewhere else and react only then. Ruby has a built-in solution for this, which is the Queue class. It is shared among all threads you spawn and thread can take an object from the queue and remove it from there. I know, it's not ideal, since you cannot "send" object to a specific thread really, only by manual filtering or having multiple queues per process, which is not so bad actually. However as we will see further, there are more useful interaction models.</p>
<p>[caption id="attachment_670" align="aligncenter" width="500"]<img class="size-full wp-image-670" src="{{ site.baseurl }}/assets/2018/07/ruby-threads.png" alt="Ruby inter-process communication" width="500" height="300" /> Ruby inter-process communication[/caption]</p>
<h2>Fibers</h2>
<p>Fibers are even more light-weight concurrency abstraction than threads. The main difference is that they are managed only by a developer. So you can manually start, stop and resume them, without the VM.</p>
<h2>Further reading</h2>
<p>I didn't cover the whole topic, so if you're interested in reading more about concurrency in Ruby, try these articles:</p>
<ul>
<li><a href="https://engineering.universe.com/introduction-to-concurrency-models-with-ruby-part-i-550d0dbb970" target="_blank" rel="noopener">https://engineering.universe.com/introduction-to-concurrency-models-with-ruby-part-i-550d0dbb970</a></li>
<li><a href="https://medium.com/@WesleyDavis/multi-threading-in-ruby-1c075f4c7410" target="_blank" rel="noopener">https://medium.com/@WesleyDavis/multi-threading-in-ruby-1c075f4c7410</a></li>
<li><a href="https://medium.com/@franzejr/ruby-3-mri-and-gil-a302577c6634" target="_blank" rel="noopener">https://medium.com/@franzejr/ruby-3-mri-and-gil-a302577c6634</a></li>
<li><a href="https://ruby-doc.org/core-2.4.1/Fiber.html" target="_blank" rel="noopener">https://ruby-doc.org/core-2.4.1/Fiber.html</a></li>
</ul>
<h2>Example</h2>
<p>An example of how the simplest Ruby app with threads may look like:<br />
[ruby]def print_numbers(thread_number)<br />
  (0..5).each do |j|<br />
    p &quot;Thread: #{thread_number}, number: #{j}&quot;<br />
    sleep(Random.rand)<br />
  end<br />
end</p>
<p>(0..5).each do |i|<br />
  Thread.new { print_numbers(i) }<br />
end</p>
<p>[/ruby]<br />
It will print something similar to:<br />
[ruby]<br />
&quot;Thread: 5, number: 1&quot;<br />
&quot;Thread: 0, number: 1&quot;<br />
&quot;Thread: 5, number: 2&quot;<br />
&quot;Thread: 2, number: 1&quot;<br />
&quot;Thread: 5, number: 3&quot;<br />
&quot;Thread: 0, number: 2&quot;<br />
&quot;Thread: 4, number: 1&quot;<br />
&quot;Thread: 1, number: 1&quot;<br />
&quot;Thread: 3, number: 1&quot;<br />
&quot;Thread: 4, number: 2&quot;<br />
...etc<br />
[/ruby]</p>
<h1>Elixir</h1>
<p>Elixir is a programming language, built on the Erlang VM and heavily influenced by Ruby. So it has all the concurrency advantages of Erlang, but Ruby-like expressive syntax.</p>
<h2>Concurrency model</h2>
<p>Elixir incorporates totally different concurrency model, which says "share nothing". So no shared memory, no shared queue to take a data from. Its model name is "Actor model". Basically, it means that every process operates on its own and can interact with any other process with the known id by sending a message to it.<br />
As for the developer, it means that no GIL exists, and inter-process communication is easily possible. Just one thing to notice, processes I'm talking about here are not OS processes which you think about, but OTP processes, which is a way lighter alternative.</p>
<p>[caption id="attachment_672" align="aligncenter" width="500"]<img class="size-full wp-image-672" src="{{ site.baseurl }}/assets/2018/07/elixir-processes.png" alt="Elixir inter-processes communication" width="500" height="300" /> Elixir inter-processes communication[/caption]</p>
<h2>Further reading</h2>
<ul>
<li><a href="http://whatdidilearn.info/2017/12/17/elixir-multiple-processes-basics.html" target="_blank" rel="noopener">http://whatdidilearn.info/2017/12/17/elixir-multiple-processes-basics.html</a></li>
<li><a href="http://whatdidilearn.info/2017/12/24/agents-and-tasks-in-elixir.html" target="_blank" rel="noopener">http://whatdidilearn.info/2017/12/24/agents-and-tasks-in-elixir.html</a></li>
<li><a href="http://whatdidilearn.info/2018/01/07/introduction-to-otp-genservers-and-supervisors.html" target="_blank" rel="noopener">http://whatdidilearn.info/2018/01/07/introduction-to-otp-genservers-and-supervisors.html</a></li>
</ul>
<p>And other articles of my friend Vitaly :)</p>
<h2>Example</h2>
<p>[ruby]<br />
defmodule NumberPrinter do<br />
  def print_numbers(thread_number) do<br />
    Enum.each 1..5, fn(j) -&gt;<br />
      IO.puts &quot;Thread: #{thread_number}, number: #{j}&quot;<br />
      :timer.sleep(Enum.random(0..500))<br />
    end<br />
  end<br />
end</p>
<p>Enum.each 1..5, fn(thread_number) -&gt;<br />
  spawn(NumberPrinter, :print_numbers, [thread_number])<br />
end<br />
[/ruby]<br />
I believe it's not the most idiomatic way of writing such a function in Elixir, but it's not my everyday language, so I have an excuse :)</p>
<h1>Go</h1>
<p>Golang uses a mechanism, called <em>goroutines</em>. The name is inspired by the term <em>coroutine</em> and which is pretty much what I've explained in the <b>Fibers</b> section of Ruby block. Though it doesn't mean that Go's goroutines have much in similar with Ruby's threads or fibers.</p>
<h2>Goroutines and Threads</h2>
<p>The main confusion I had, was to think of goroutines as of threads. Yet they are actually pretty different. Here are some of the differences:</p>
<ul>
<li>Thread usually allocates about 1MB of RAM. Goroutine takes just 2KB at the start. Just to mention, Elixir's threads allocate even less, about 0.5KB.</li>
<li>Since their size is smaller, you can run much more of them and their spawn time is faster</li>
<li>Threads belongs to one process and hence one processor. Goroutines can also use multiple processors/cores</li>
</ul>
<h2>Example</h2>
<p>Since we're learning Go here, I will provide an example right ahead.<br />
[cpp]<br />
package main</p>
<p>import (<br />
	&quot;fmt&quot;<br />
	&quot;time&quot;<br />
)</p>
<p>func print_numbers(thread_number int) {<br />
	for j := 0; j &lt; 5; j++ {<br />
		time.Sleep(100 * time.Millisecond)<br />
		fmt.Println(&quot;Thread: &quot;, thread_number, &quot;, number: &quot;, j)<br />
	}<br />
}</p>
<p>func main() {<br />
	for thread_number := 1; thread_number &lt; 6; thread_number++ {<br />
		time.Sleep(100 * time.Millisecond)<br />
		go print_numbers(thread_number)<br />
	}</p>
<p>	print_numbers(0)<br />
}<br />
[/cpp]<br />
<em>(<a href="https://play.golang.org/p/2RiW0uF3eAR" target="_blank" rel="noopener">https://play.golang.org/p/2RiW0uF3eAR</a>)</em></p>
<p>In Golang in order to spawn a goroutine, the only thing you have to do is to call a function using <code>go</code> command. In the example above I show that you can call the <code>print_numbers</code> function both asynchronously as a goroutine and in the main thread.</p>
<h2>Inter-goroutine communication</h2>
<p>The communication model in Go lays somewhere in between a shared queue and messages. Golang uses so-called "channels" to pass messages/objects from one goroutine to another. The main difference with a shared queue is that channel is not shared among all goroutines, but you can manually decide, to which goroutines to provide an access to it. The main difference with messages of OTP's Actor model is that in Elixir you pass message by the PID, but in Go anyone having a channel reference can read from it.</p>
<p>[caption id="attachment_673" align="aligncenter" width="500"]<img class="size-full wp-image-673" src="{{ site.baseurl }}/assets/2018/07/goroutines.png" alt="Go goroutines communication" width="500" height="300" /> Go goroutines communication[/caption]<br />
[cpp]<br />
package main</p>
<p>import (<br />
	&quot;fmt&quot;<br />
	&quot;time&quot;<br />
)</p>
<p>func print_numbers(thread_number int, messages chan string) {<br />
	for j := 0; j &lt; 5; j++ {<br />
		time.Sleep(100 * time.Millisecond)<br />
		messages &lt;- fmt.Sprintf(&quot;Thread: %v, number: %v&quot;, thread_number, j)<br />
	}<br />
}</p>
<p>func main() {<br />
	messages := make(chan string)<br />
	for thread_number := 1; thread_number &lt; 6; thread_number++ {<br />
		time.Sleep(100 * time.Millisecond)<br />
		go print_numbers(thread_number, messages)<br />
	}</p>
<p>	for {<br />
		message := &lt;-messages<br />
		fmt.Println(message)<br />
	}<br />
}<br />
[/cpp]<br />
<em>(<a href="https://play.golang.org/p/1e363VD1BMY" target="_blank" rel="noopener">https://play.golang.org/p/1e363VD1BMY</a>)</em></p>
<p>In this example instead of printing strings right in the goroutine, we push them to the channel and then in the main function we're constantly reading from the channel and printing everything stored there.</p>
<p>If you're still not quite sure, what is the difference between these three implementations, below you'll find a list of useful articles to delve&nbsp;deeper.</p>
<h2>Further reading</h2>
<ul>
<li><a href="http://tleyden.github.io/blog/2014/10/30/goroutines-vs-threads/" target="_blank" rel="noopener">http://tleyden.github.io/blog/2014/10/30/goroutines-vs-threads/</a></li>
<li><a href="https://codeburst.io/why-goroutines-are-not-lightweight-threads-7c460c1f155f" target="_blank" rel="noopener">https://codeburst.io/why-goroutines-are-not-lightweight-threads-7c460c1f155f</a></li>
<li><a href="https://blog.codeship.com/comparing-elixir-go/" target="_blank" rel="noopener">https://blog.codeship.com/comparing-elixir-go/</a></li>
<li><a href="https://medium.com/@learnitnow/ruby-vs-elixir-vs-go-a-concurrency-comparision-d2330c1fa3a6" target="_blank" rel="noopener">https://medium.com/@learnitnow/ruby-vs-elixir-vs-go-a-concurrency-comparision-d2330c1fa3a6</a></li>
</ul>
<p>In the next post, we will discover goroutines deeper, addressing such topics as buffered channels, direction selection, and pipelines.</p>
<p>I hope it was useful, feel free to add suggestions, share or even appreciate by clicking on a big orange button below %)		</p>
