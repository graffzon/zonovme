---
layout: post
title: Зачем монга
date:
type: post
parent_id: '0'
published: false
password: ''
status: draft
categories:
- No category
tags: []
meta:
  _edit_last: '1'
author:
  login: graffzon
  email: graffzon@gmail.com
  display_name: graffzon
  first_name: ''
  last_name: ''
permalink: "/"
excerpt: "\n\t\t\t\t\t\t"
---
<p>
				Привет, коллеги.</p>
<p>На днях я начал цикл статей в своем блоге, который будет посвящен индексам в MongoDB, в этой же статье на прекрасной площадке mdkev'а я хочу вам рассказать, почему вообще Mongo и стоит ли вам смотреть в ее сторону.</p>
<p>Для начала пару слов о моем опыте с ней. Попробовал я ее первый раз года четыре назад, когда она стала модная и все хотели ее попробовать, потому что NoSQL это то, что нужно любому стартапу!!! (на самом делел нет, читайте дальше) Но тогда дело далеко не зашло, побаловался, даже в каком-то из MVP ее применили, но в продакшн дело не пошло. С тех пор я ее, можно сказать, позабыл. Однако полтора года назад я устроился в компанию, где MongoDB активно используется. Там была развестистая микросервисная архитектура и один из микросервисов, весьма не микро, использовал как раз эту базу данных. Тут я вкусил ее по полной. Испытал и чувство наслаждения от того, как все легко меняется, и взрывы гнева от того, что неожиданности в ее поведении порой были слишком неожиданными. Теперь же я работаю в другом месте и Монга у нас используется с полной осознанностью с моей стороны и прикасаюсь я к ней ежедневно, можно даже сказать, ежечасно.</p>
<p>Итак, давайте разберем, почему вам стоит рассмотреть использование MongoDB в вашем проекте.</p>
<h3>1. Отсутствие схемы.</h3>
<p>Это самое очевидное преимущество. Если вы работаете над новым стартапов, в которым бизнес-модель еще не до конца ясна и с большой вероятностью проект до выхода на рынок претерпит множество изменений, в том числе на уровне организации данных - посмотрите в сторону NoSQL решений, в частности на Монгу. Все дело в том, что в отличие от моего горячо любимого PostgreSQL в Монге просто нет необходимости создавать таблицы, менять их схемы, создавать миграции, заботиться о типах данных. Однако тут будьте осторожны. Очевидный плюс этого пункта, что вам гораздо проще создавать новые таблицы, добавлять и убирать поля. Настолько просто, что в Mongoid (ORM для MongoDB) вы просто добавляете в вашу модель строчку а-ля <code>field :text, type: String</code> и все, при следующей записи в бд у нового элемента будет это поле. Если же вы вставляете данные без ORM - то вам и никакие "строчки" не нужны - просто пихайте, что душе угодно. Но тут же и темная сторона этой силы. Вы не можете быть вполне уверены, что в конкретном документе у вас есть конкретное поле. <em>(примечание: документами в MongoDB называются записи в коллекции)</em>. Т.е. если раньше у вас не было поля text и вы добавили несколько записей, а потом добавили это поле и добавили еще записи - в старых записях у вас этого поля, конечно же, не появится. Спасибо Mongoid, он сделает вид, что такое поле есть и у них и просто вернет значение null.</p>
<h3>2. Легкость горизонтального масштабирования.</h3>
<p>Горизонтальное масштабирование требуется когда вам необходимо запихнуть в базу данных информации больше, чем диск на вашем сервере. Все, что связано с горизонтальным масштабированием является визитной карточкой любой NoSQL базы данных. Дальше они уже соревнуются в том, у кого выше надежность, у кого быстрее запись, у кого быстрее чтение и т.д. На момент написания этой статьи в PostgreSQL нет встроенного механизма горизонтального масштабирования. Есть сторонние проприетарные решения (не могу не упомянуть компанию Citus, они делают прекрасную работу). В MongoDB же это делается предельно просто, а статей про это написано много, и механизмы репликации вкупе с шардированием на ней работают прекрасно. Кроме того можно как позволить балансировщику автоматически выбирать, в какой шард складывать конкретные докуенты, так и задать правила относительно какого-то поля или набора болей.</p>
<h3>3. Богатая функция аггрегации.</h3>
<p>Язык SQL очень богатый и всем привычный, камней бросать я в него не стану. Однако то, как позволяет получать данные Монга однозначно заслуживает похвалы. Тут вам и map-reduce, и группировки по сложным условиям, и переформатирование документов на лету, и получение случайных документов, и сортировки. В общем все то, что вы можете выжать из SQL БД, плюс возможность записывать все это в формате pipeline'ов и с более читаемым синтаксисом.</p>
<p>Вот один из многих примеров из документации:</p>
<table class="docutils" border="1">
<tbody valign="top">
<tr class="row-even">
<td>
<div class="first last highlight-sql">
<div class="highlight">
<pre><span class="k">SELECT</span> <span class="n">cust_id</span><span class="p">,</span>
       <span class="k">SUM</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="k">as</span> <span class="n">total</span>
<span class="k">FROM</span> <span class="n">orders</span>
<span class="k">WHERE</span> <span class="n">status</span> <span class="o">=</span> <span class="s1">'A'</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">cust_id</span>
<span class="k">HAVING</span> <span class="n">total</span> <span class="o">&gt;</span> <span class="mi">250</span>
</pre>
</div>
</div>
</td>
<td>
<div class="first last highlight-javascript">
<div class="highlight">
<pre><span class="nx">db</span><span class="p">.</span><span class="nx">orders</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">(</span> <span class="p">[</span>
<span class="hll">   <span class="p">{</span> <span class="nx">$match</span><span class="o">:</span> <span class="p">{</span> <span class="nx">status</span><span class="o">:</span> <span class="s1">'A'</span> <span class="p">}</span> <span class="p">},</span>
</span><span class="hll">   <span class="p">{</span>
</span><span class="hll">     <span class="nx">$group</span><span class="o">:</span> <span class="p">{</span>
</span><span class="hll">        <span class="nx">_id</span><span class="o">:</span> <span class="s2">"$cust_id"</span><span class="p">,</span>
</span><span class="hll">        <span class="nx">total</span><span class="o">:</span> <span class="p">{</span> <span class="nx">$sum</span><span class="o">:</span> <span class="s2">"$price"</span> <span class="p">}</span>
</span><span class="hll">     <span class="p">}</span>
</span><span class="hll">   <span class="p">},</span>
</span><span class="hll">   <span class="p">{</span> <span class="nx">$match</span><span class="o">:</span> <span class="p">{</span> <span class="nx">total</span><span class="o">:</span> <span class="p">{</span> <span class="nx">$gt</span><span class="o">:</span> <span class="mi">250</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span>
</span><span class="p">]</span> <span class="p">)</span></pre>
</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Пример MongoDB справа хоть и чуть более многословный, но гораздо более адекватно структурированый. Если вы только пришли с SQL базы данных, потребуется какое-то время на привыкание, но потом привыкаешь и возвращаться не хочется.</p>
<h3>4. Создана для денормализации.</h3>
<p>В MongoDB принято хранить данные так, как вам это удобно. В SQL базах данных <em>всегда (примечание: на самом деле нет, стоит всегда думать головой и не воспринимать слово "всегда" как закон)</em> стоит заботиться об организации данных, чтобы таблицы были нормализованные, а запросы строить так, чтобы они могли левой пяткой глаз почесать, но данные достать. В Монго если вам неудобно, в каком формате или в каком месте лежат данные - вы с чистой совестью можете их или переместить, потому что отсутствие схемы это подразумевает, или просто продублирвать данные в нужное место. Т.е. фактически у вас может быть одно и то же поле с одними и теми же данными, но в разных коллекциях. Или два поля в одной коллекции, а плюс к ним еще одно поле, которое является композицией первых двух. Но это опять таки та сила, которую следует применять с умом. Если вы будете неконтролируемо плодить поля в документах, поддержка на уровне понимания разработчиком сущности будет становиться все труднее и труднее.</p>
<h3>5. Простой формат индексов.</h3>
<p>Индексы в MongoDB называются предельно понятно и их использование практически лишено подводных камней. Например в Постгресе если у вас есть b-tree индекс на одно поле и gist индекс на другое - при запросе, который использует оба этих индекса, использоваться будет только один из них. В Монге таких сюрпризов меньше. Как я уже упомянул - подробнее про индексы в Монге я начал писать в своем блоге (zonov.me).</p>
<p>&nbsp;</p>
<h2>Заключение</h2>
<p>Несомненно MongoDB не серебряная пуля. В ней есть свои неожиданные подводные камни. Например она автоматически не отрубает медленные запросы и они продолжают висеть, пока вы их не закроете саомостоятельно. Еще вы можете испытать низкую производительность при count запросе на больших коллекциях. Но это все вещи, которые ты однажды узнаешь и потом просто помнишь о них, потому что жить они не сильно мешают. Я не агитирую всех уходить с SQL БД и переводить продакшн проекты на Монгу, но если вы стоите перед выбором, какую базу данных взять для нового проекта - подумайте о ней. Если все-таки не решитесь экспериментировать с NoSQL решением - тогда берите PostgreSQL. Они очень динамично развиваются, у них есть частично-nosql решение в виде json полей в таблице, огромное количество документации и прекрасная производительность. В общем не пожалеете. Но это тема для другой статьи.		</p>
